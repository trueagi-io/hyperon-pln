;; Implement functions to convert terms between MeTTa, lambda calculus
;; and combinatory logic.
;;
;; For the lambda calculus <-> combinatory logic part, the code is
;; inspired from the paper:
;;
;; A correct-by-construction conversion from lambda calculus to
;; combinatory logic, by Wouter Swierstra.
;;
;; As in the paper, the version of combinatory logic in consideration
;; is S, K, I.  For now S, the combinator, cannot be confused with S,
;; the successor function, because Nat is not defined here, however we
;; may want in the future to represent these combinators as AS, AK, ID
;; to not be confused with S, the successor function.  Also all
;; functions are explicitly curried, thus K x y is represented in
;; MeTTa as ((K x) y).
;;
;; On the lambda-calculus side, the MeTTa representation of a lambda
;; abstraction is (Î» <VAR> <BODY>).  Applications are explicitly
;; curried as well, thus (x y z) is represented ((x y) z).

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Common functions and types ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define Maybe type
(: Maybe (-> $a Type))
(: Nothing (Maybe $a))
(: Just (-> $a (Maybe $a)))

;; Define list type
(: List (-> $a Type))
(: Nil (List $a))
(: Cons (-> $a (List $a) (List $a)))

;; Define is-expression, a function that returns True iff the input is
;; a MeTTa expression, meaning it is not a symbol or a variable.
(: is-expression (-> Atom Bool))
(= (is-expression $x) (== (get-metatype $x) Expression))

;; Test is-expression
!(assertEqual (is-expression $x) False)
!(assertEqual (is-expression A) False)
!(assertEqual (is-expression (A B)) True)

;; Define is-variable, a function that returns True iff its input is a
;; MeTTa variable.
(: is-variable (-> Atom Bool))
(= (is-variable $x) (== (get-metatype $x) Variable))

;; Test is-variable
!(assertEqual (is-variable $x) True)
!(assertEqual (is-variable A) False)
!(assertEqual (is-variable (A $x)) False)

;; Define is-symbol, a function that returns True iff its input is a
;; MeTTa symbol.
(: is-symbol (-> Atom Bool))
(= (is-symbol $x) (== (get-metatype $x) Symbol))

;; Test is-symbol
!(assertEqual (is-symbol $x) False)
!(assertEqual (is-symbol A) True)
!(assertEqual (is-symbol (A $x)) False)

;; Till lazy or and and gets into the stdlib
(: lazy-or (-> Bool Atom Bool))
(= (lazy-or False $x) $x)
(= (lazy-or True $x) True)
(: lazy-and (-> Bool Atom Bool))
(= (lazy-and False $x) False)
(= (lazy-and True $x) $x)

;; Return True iff the first argument is a subterm of the second
;; argument.
;;
;; For instance
;;
;; (is-subterm-of A A) returns True
;; (is-subterm-of A (A B)) returns True
;; (is-subterm-of A B) returns False
;; (is-subterm-of A (B C)) returns False
;;
;; It should handle variables properly (that is assume that variables
;; with different names are different terms), for instance
;;
;; (is-subterm-of $x $x) returns True
;; (is-subterm-of $x ($x $y)) returns True
;; (is-subterm-of $x $y) returns False
;; (is-subterm-of $x ($y $z)) return False
;;
;; Terms can of course contain both symbols and variables, for
;; instance
;;
;; (is-subterm-of A ($x A)) returns True
;; (is-subterm-of $x ($x A)) returns True
;; (is-subterm-of A ($x B)) returns False
;; (is-subterm-of $x ($y A)) returns False
;;
;; It should of course detect a subterm when it is buried deeper
;; inside the superterm, for instance
;;
;; (is-subterm-of A (C (B A))) returns True
;; (is-subterm-of A (B (C D))) returns False
(: is-subterm-of (-> Atom Atom Bool))
(= (is-subterm-of $x $y)
   ;; Base cases
   (if (== $x $y)
       True
       (if (== $y ())
           False
           ;; Recursive step
           (if (is-expression $y)
               (lazy-or (let $head (car-atom $y) (is-subterm-of $x $head))
                        (let $tail (cdr-atom $y) (is-subterm-of $x $tail)))
               ;; Final base case
               False))))

;; Test is-subterm-of
!(assertEqual (is-subterm-of A A) True)
!(assertEqual (is-subterm-of A ()) False)
!(assertEqual (is-subterm-of A (A B)) True)
!(assertEqual (is-subterm-of A B) False)
!(assertEqual (is-subterm-of A (B C)) False)
!(assertEqual (is-subterm-of $x $x) True)
!(assertEqual (is-subterm-of $x ($x $y)) True)
!(assertEqual (is-subterm-of $x $y) False)
!(assertEqual (is-subterm-of $x ($y $z)) False)
!(assertEqual (is-subterm-of A ($x A)) True)
!(assertEqual (is-subterm-of $x ($x A)) True)
!(assertEqual (is-subterm-of A ($x B)) False)
!(assertEqual (is-subterm-of $x ($y A)) False)
!(assertEqual (is-subterm-of A (C (B A))) True)
!(assertEqual (is-subterm-of A (B (C D))) False)

;; Return True iff the expression is a tuple of variables
(: all-variables (-> Expression Bool))
(= (all-variables $x) (if (== $x ())
                             True
                             (lazy-and (let $head (car-atom $x) (is-variable $head))
                                  (let $tail (cdr-atom $x) (all-variables $tail)))))

;; Return True iff the expression is a tuple of unique variables.
;; Note that it only supports pairs and triples because that is all we
;; need here.
(: uniq-vars (-> Expression Bool))
(= (uniq-vars ($x $y)) (lazy-and (all-variables ($x $y)) (not (== $x $y))))
(= (uniq-vars ($x $y $z)) (lazy-and (all-variables ($x $y $z))
                               (lazy-and (not (== $x $y))
                                    (lazy-and (not (== $y $z))
                                         (not (== $x $z))))))

;; Define Î±-Binding type, that represents a binding from a variable to
;; another variable.
(: Î±-Binding Type)
(: â†”Î± (-> Variable Variable Î±-Binding))

;; Insert an Î±-binding in a list of Î±-bindings.  Returns maybe the new
;; list of Î±-bindings if the insertion succeeded, that is the
;; Î±-binding is consistent with the list, or entirely missing from it.
(: Î±-insert (-> Î±-Binding (List Î±-Binding) (Maybe (List Î±-Binding))))
;; Base case
(= (Î±-insert (â†”Î± $x $y) Nil) (Just (Cons (â†”Î± $x $y) Nil)))
;; Recursive step
(= (Î±-insert (â†”Î± $x $y) (Cons (â†”Î± $z $w) $tail))
   (if (== $x $z)
       (if (== $y $w)
           (Just (Cons (â†”Î± $z $w) $tail))
           Nothing)
       (if (== $y $w)
           Nothing
           (case (Î±-insert (â†”Î± $x $y) $tail)
             ((Nothing Nothing)
              ((Just $Î½tl) (Just (Cons (â†”Î± $z $w) $Î½tl))))))))

;; Test Î±-insert
!(assertEqual
  (Î±-insert (â†”Î± $x $y) Nil)
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-insert (â†”Î± $x $y) (Cons (â†”Î± $x $y) Nil))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-insert (â†”Î± $x $y) (Cons (â†”Î± $x $z) Nil))
  Nothing)
!(assertEqual
  (Î±-insert (â†”Î± $x $y) (Cons (â†”Î± $z $w) Nil))
  (Just (Cons (â†”Î± $z $w) (Cons (â†”Î± $x $y) Nil))))

;; Join two Î±-bindings to produce an Î±-bindings consisting of the
;; union of these.  If the two Î±-bindings provided in input are
;; inconsistent, or one of them in Nothing, then return Nothing.
(: Î±-join (-> (Maybe (List Î±-Binding))
              (Maybe (List Î±-Binding))
              (Maybe (List Î±-Binding))))
;; Base cases
(= (Î±-join Nothing Nothing) Nothing)
(= (Î±-join Nothing (Just $_)) Nothing)
(= (Î±-join (Just $_) Nothing) Nothing)
(= (Î±-join (Just Nil) (Just $other)) (Just $other))
;; Recursive step
(= (Î±-join (Just (Cons $head $tail)) (Just $other))
   (Î±-join (Just $tail) (Î±-insert $head $other)))

;; Test Î±-join
!(assertEqual
  (Î±-join Nothing Nothing)
  Nothing)
!(assertEqual
  (Î±-join (Just Nil) (Just Nil))
  (Just Nil))
!(assertEqual
  (Î±-join (Just Nil) (Just (Cons (â†”Î± $x $y) Nil)))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-join (Just (Cons (â†”Î± $x $y) Nil)) (Just Nil))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-join (Just Nil) (Just (Cons (â†”Î± $x $y) Nil)))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-join (Just (Cons (â†”Î± $x $y) Nil)) (Just (Cons (â†”Î± $x $z) Nil)))
  Nothing)
!(assertEqual
  (Î±-join (Just (Cons (â†”Î± $x $y) Nil)) (Just (Cons (â†”Î± $x $y) Nil)))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-join (Just (Cons (â†”Î± $x $y) Nil)) (Just (Cons (â†”Î± $z $w) Nil)))
  (Just (Cons (â†”Î± $z $w) (Cons (â†”Î± $x $y) Nil))))

;; Given two terms, $lhs and $rhs, return maybe a list of Î±-bindings
;; so that if $lhs is Î±-equivalent to $rhs, substituting all variables
;; in $rhs according to the Î±-bindings would result in a term that is
;; equal to $lhs.  If $lhs and $rhs are not Î±-equivalent then return
;; Nothing.
(: Î±-bindings (-> Atom Atom (Maybe (List Î±-Binding))))
(= (Î±-bindings $lhs $rhs)
   (case (get-metatype $lhs)
     ((Symbol (if (== $lhs $rhs)
                  (Just Nil)
                  Nothing))
      (Grounded (if (== $lhs $rhs)
                    (Just Nil)
                    Nothing))
      (Variable (if (is-variable $rhs)
                    (Just (Cons (â†”Î± $lhs $rhs) Nil))
                    Nothing))
      (Expression (if (== $lhs ())
                      ;; $lhs is ()
                      (if (== $rhs ())
                          (Just Nil)
                          Nothing)
                      ;; $lhs is not ()
                      (if (== $rhs ())
                          Nothing
                          (case (get-metatype $rhs)
                            ((Symbol Nothing)
                             (Grounded Nothing)
                             (Variable Nothing)
                             (Expression
                              (let* (($hd-lhs (car-atom $lhs))
                                     ($tl-lhs (cdr-atom $lhs))
                                     ($hd-rhs (car-atom $rhs))
                                     ($tl-rhs (cdr-atom $rhs))
                                     ($hd-Î±-bs (Î±-bindings $hd-lhs $hd-rhs))
                                     ($tl-Î±-bs (Î±-bindings $tl-lhs $tl-rhs)))
                                (Î±-join $hd-Î±-bs $tl-Î±-bs)))))))))))

;; Test Î±-bindings
!(assertEqual
  (Î±-bindings A B)
  Nothing)
!(assertEqual
  (Î±-bindings $x B)
  Nothing)
!(assertEqual
  (Î±-bindings () ())
  (Just Nil))
!(assertEqual
  (Î±-bindings (R $x) $y)
  Nothing)
!(assertEqual
  (Î±-bindings $x $y)
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-bindings (R $x) (R $y))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-bindings ((R $x) A) ((R $y) $z))
  Nothing)
!(assertEqual
  (Î±-bindings ((R $x) $x) ((R $z) $w))
  Nothing)
!(assertEqual
  (Î±-bindings ((R $x) $y) ((R $z) $z))
  Nothing)
!(assertEqual
  (Î±-bindings (R $x (R $y)) (R $z $z))
  Nothing)
!(assertEqual
  (Î±-bindings ((R $x) $y) ((R $z) $w))
  (Just (Cons (â†”Î± $y $w) (Cons (â†”Î± $x $z) Nil))))

;; Return True iff two given terms are alpha-equivalent.  For now all
;; variables are assumed to be free, the notion of scope is not
;; implemented.
(: =Î± (-> Atom Atom Bool))
(= (=Î± $lhs $rhs) (case (Î±-bindings $lhs $rhs)
                    ((Nothing False)
                     ((Just $_) True))))

;; Test =Î±
!(assertEqual (=Î± $x $x) True)
!(assertEqual (=Î± $x $y) True)
!(assertEqual (=Î± A B) False)
!(assertEqual (=Î± A $y) False)
!(assertEqual (=Î± (R $x) (R $y)) True)
!(assertEqual (=Î± (R $x $x) (R $y $z)) False)
!(assertEqual (=Î± (R $x (R $y)) (R $z $z)) False)
!(assertEqual (=Î± (Î» $x (Î» $y $x)) (Î» $z (Î» $w $z))) True)

;;;;;;;;;;;;;;;;;;;;;
;; Reduction rules ;;
;;;;;;;;;;;;;;;;;;;;;

;; NEXT: fix lambda application reduction, see
;; https://github.com/trueagi-io/metta-examples/issues/39

;; Reduce lambda application
;; (= ((Î» $x $f) $y) (let $x $y $f))
;; (= ((Î» $x $f) $y) (let ($Î½x $Î½f) (sealed ($x) ($x $f)) (let $Î½x $y $Î½f)))

;; ;; Test lambda calculus reduction
;; !(((Î» $f378 (Î» $g379 (Î» $x380 (($f378 $x380) ($g379 $x380))))) (((Î» $f448 (Î» $g449 (Î» $x450 (($f448 $x450) ($g449 $x450))))) ((Î» $x470 (Î» $y471 $x470)) (Î» $f482 (Î» $g483 (Î» $x484 (($f482 $x484) ($g483 $x484))))))) (((Î» $f543 (Î» $g544 (Î» $x545 (($f543 $x545) ($g544 $x545))))) ((Î» $x564 (Î» $y565 $x564)) (Î» $x570 (Î» $y571 $x570)))) (Î» $x579 $x579)))) ((Î» $x604 (Î» $y605 $x604)) (Î» $x610 $x610)))
;; ;; Should reduce to (Î» $f (Î» $x ($f $x)))

;; Reduction rules for combinatory logic.  We introduce combinators ðŒ,
;; ð, ð“, ð–, ð, ð‚ and ð” in the process.
(= (ðˆ $x) $x)
(= ((ðŠ $x) $y) $x)
(= (((ð’ $x) $y) $z) (($x $z) ($y $z)))
(= (ðŒ $x) ($x $x))
(= ((ð $x) $y) $y)
(= ((ð“ $x) $y) ($y $x))
(= ((ð– $x) $y) (($x $y) $y))
(= (((ð $x) $y) $z) ($x ($y $z)))
(= (((ð‚ $x) $y) $z) (($x $z) $y))
(= ((ð” $x) $y) ($y (($x $x) $y)))
(= ((ð’ ðŠ) ðŠ) ðˆ)
(= ((ð’ ðˆ) ðˆ) ðŒ)
(= (ðŠ ðˆ) ð)
(= ((ð’ (ðŠ (ð’ ðˆ))) ðŠ) ð“)
(= ((ð’ ð’) ð) ð–)
(= ((ð’ (ðŠ ð’)) ðŠ) ð)
(= ((ð’ (ð ð ð’)) (ðŠ ðŠ)) ð‚)
(= ((ð (ð’ ðˆ)) (ð’ ðˆ ðˆ)) ð”)

;; ;; Test combinatory logic reduction
;; !(assertEqual
  ;; !((ð’ ((ð’ (ðŠ ð’)) ((ð’ (ðŠ ðŠ)) ðˆ))) (ðŠ ðˆ)) ; Result of converting
  ;;                                                 ; (lc2cl (Î» $f (Î» $x ($f $x))))
  ;;                                                 ; which 1 in lambda calculus
  ;; ((ð’ ((ð’ (ðŠ ð’)) ((ð’ (ðŠ ðŠ)) ðˆ))) (ðŠ ðˆ))) ; Unreducable???

;; !(assertEqual
;;   (((ð’ (ðŠ ð’)) ðŠ) (ðŠ ðˆ))  ; 1, obtained by (S Z) in combinatory logic
;;   (ð ð))                 ; NEXT: shouldn't it be ((ð’ ð) ð)?

;; !(assertEqual
;;   (((ð’ (ðŠ ð’)) ðŠ) (((ð’ (ðŠ ð’)) ðŠ) (ðŠ ðˆ)))  ; 2, obtained by (S (S Z)) in combinatory logic
;;   (ð (ð ð)))

;; ;; !(assertEqual
;;   !((ð’ ð) ð) ; 3, obtained by (S (S (S Z))) in combinatory logic
;;   !((ð’ ð) ((ð’ ð) ð)) ; 3, obtained by (S (S (S Z))) in combinatory logic
;;   ;; (ð (ð (ð ð))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Combinatory logic to Î»-calculus ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Convert combinatory logic term to lambda-calculus
(: cl2lc (-> Atom Atom))
;; Base cases
(= (cl2lc ID) (Î» $x $x))
(= (cl2lc AK) (Î» $x (Î» $y $x)))
(= (cl2lc AS) (Î» $f (Î» $g (Î» $x (($f $x) ($g $x))))))
(= (cl2lc AM) (Î» $x ($x $x)))
;; Recursive step
(= (cl2lc ($f $g)) ((cl2lc $f) (cl2lc $g)))

;; Test cl2lc

;; According to ChatGPT the following holds (NEXT: make sure there are
;; no hallucination):
;;
;; Z (zero) would be represented by
;; - combinatory logic: (AK ID)
;; - lambda calculus: (Î» $f (Î» $x $x))
;;
;; S (successor) would be represented by (NEXT: is it really the case?)
;; - combinatory logic: ((AS (AK AS)) AK)
;; - lambda calculus: (Î» $n (Î» $f (Î» $x ($f (($n $f) $x)))))
;;
;; 1 would be represented by
;; - combinatory logic: NEXT
;; - lambda calculus: (Î» $f (Î» $x ($f $x)))
;;
;; 2 would be represented by
;; - combinatory logic: ((((AS (AK AS)) AK) ((AS (AK AS)) AK)) (AK ID))
;; - lambda calculus: (Î» $f (Î» $x ($f ($f $x))))
;;
;; plus (addition) would be represented by
;; - combinatory logic: ((AS (AS AK)) ID)
;; - lambda calculus: ((Î» $m) ((Î» $n) ((Î» $f) ((Î» $x) (($m f) (($n $f) $x))))))
;;
;; times (multiplication) would be represented by
;; - combinatory logic: ((AS ((AS (AK AS)) AK)) ID)
;; - lambda calculus: ((Î» $m) ((Î» $n) ((Î» $f) ((Î» $x) (($m ($n $f)) $x)))))

;; ;; Convert (AK ID) to (Î» $f (Î» $x $x)) (zero in lambda calculus)
;; ;;
;; ;; TODO: re-enable assertEqual when it will support alpha-equivalence.
;; ;; Maybe we should introduce something like assertAlphaEqual.
;; ;;
;; ;; !(assertEqual
;;   !(cl2lc (AK ID))
;;   ;; (Î» $f (Î» $x $x)))

;; ;; Convert ((AS ID) ID) to (Î» $x ($x $x)) (M, the Mockingbird combinator)
;; !(cl2lc ((AS ID) ID))

;; ;; Disabled because it does not half, as it should
;; ;; Convert (AM AM) (reduction should not halt)
;; ;; !(cl2lc (AM AM))

;; ;; Convert (AS ID) to
;; !(cl2lc (AS ID))

;; ;; NEXT: find out if the following is correct

;; ;; Convert ((AS (AK AS)) AK) to
;; ;; (Î» $n (Î» $f (Î» $x ($f (($n $f) $x))))) (successor in lambda calculus)
;; !(cl2lc ((AS (AK AS)) AK))

;; ;; Convert 1 to lambda calculus
;; !(cl2lc ((((AS (AK AS)) AK) ((AS (AK AS)) AK)) (AK ID)))

;; ;; Convert 2 to lambda calculus
;; !(cl2lc ((((AS (AK AS)) AK) ((AS (AK AS)) AK)) (AK ID)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Î»-calculus to combinatory logic ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Convert lambda-calculus term to combinatory logic term.
(: lc2cl (-> Atom Atom))
(= (lc2cl $term)
   (if (is-expression $term)
       ;; Base cases
       (if (== $term ())
           ()
           (if (=Î± $term (Î» $x $x))
               ID
               (if (=Î± $term (Î» $x (Î» $y $x)))
                   AK
                   (if (=Î± $term (Î» $f (Î» $g (Î» $x (($f $x) ($g $x))))))
                       AS
                       (if (=Î± $term (Î» $x ($x $x)))
                           AM
                           ;; Recursive steps
                           (case $term
                             (((Î» $x $f)
                               (if (is-variable $x)
                                   (let $clf (lc2cl $f)
                                     (if (is-subterm-of $x $f)
                                         ;; Build AS
                                         (if (is-expression $clf)
                                             (case $clf
                                               ((($g $h) ((AS (lc2cl (Î» $x $g))) (lc2cl (Î» $x $h))))
                                                ($_ (empty))))
                                             $clf)
                                         ;; Build AK
                                         (AK $clf)))
                                   (empty)))
                              (($f $g) ((lc2cl $f) (lc2cl $g))))))))))
       $term))

;; Test lc2cl
!(assertEqual
  (lc2cl $f)
  $f)
!(assertEqual
  (lc2cl ($f $x))
  ($f $x))
!(assertEqual
  (lc2cl ($f ($f $x)))
  ($f ($f $x)))
!(assertEqual
  (lc2cl (Î» $x $x))
  ID)
!(assertEqual
  (lc2cl (Î» $x (Î» $y $x)))
  AK)
!(assertEqual
  (lc2cl (Î» $f (Î» $g (Î» $x (($f $x) ($g $x))))))
  AS)
!(assertEqual
  (lc2cl (Î» $x ($x $x)))
  AM)
!(assertEqual
  (lc2cl (Î» $x $f))
  (AK $f))
!(assertEqual
  (lc2cl (Î» $x ($f $g)))
  (K ($f $g)))
!(assertEqual
  (lc2cl (Î» $x ($f ($f $x))))
  ((AS (K $f)) (K ($f $g))))
!(assertEqual
  (lc2cl (Î» $f (Î» $x $x)))    ; Zero in lambda calculus
  (AK ID))                    ; Zero in combinatory logic
!(assertEqual
  (lc2cl (Î» $f (Î» $x ($f ($f $x)))))    ; Two in lambda calculus
  (...))                           ; NEXT: Two in combinatory logic

;; NEXT: find out why the following does not work

;; ;; ;; Convert (Î» $g (Î» $x ($g $x))) to ?
;; ;; !(lc2cl (Î» $g (Î» $x ($g $x))))

;; ;; ;; ;; Convert (Î» $g (Î» $x ($x ($g $x)))) to ?
;; ;; ;; !(lc2cl (Î» $g (Î» $x ($x ($g $x)))))

;; ;; ;; ;; Convert ((Î» $f (Î» $g (Î» $x (($f $x) ($g $x))))) (Î» $y $y)) to (AS ID)
;; ;; ;; !(lc2cl ((Î» $f (Î» $g (Î» $x (($f $x) ($g $x))))) (Î» $y $y)))

;; ;; ;; ;; Convert S from lambda calculus to combinatory logic.  That is
;; ;; ;; ;; (Î» $n (Î» $f (Î» $x ($f (($n $f) $x))))) |-> ((AS (AK AS)) AK)
;; ;; ;; !(lc2cl (Î» $n (Î» $f (Î» $x ($f (($n $f) $x))))))

;; ;; ;; (Î» $n (Î» $f (Î» $x ($f (($n $f) $x)))))
;; ;; ;; -->

;; ;; ;;;;;;;;;;;;;;;;;;;;;;;;;
;; ;; ;; MeTTa to Î»-calculus ;;
;; ;; ;;;;;;;;;;;;;;;;;;;;;;;;;

;; ;; ;; NEXT:
;; ;; ;; 1. replace LET by let (if possible)
;; ;; ;; 2. support let*

;; ;; ;; Convert a MeTTa expression to lambda calculus
;; ;; (: mt2lc (-> Atom Atom))
;; ;; (= (mt2lc $expr)
;; ;;    (if (is-variable $expr)
;; ;;        $expr
;; ;;        (case $expr
;; ;;          (((LET $x $y $f) ((Î» $x (mt2lc $f)) (mt2lc $y)))  ; Let
;; ;;           (($f $x) ((mt2lc $f) (mt2lc $x)))                ; Application
;; ;;           ($s $s)))))                                      ; Symbol

;; ;; ;; !(mt2lc
;; ;; ;;   (LET $spleeter-output
;; ;; ;;        (snet.sound-spleeter.spleeter ((snet.sound-spleeter.MkInput "") $input))
;; ;; ;;        (LET $english-vocals (snet.sound-spleeter.Output.vocals $spleeter-output)
;; ;; ;;             (LET $chinese-lyrics
;; ;; ;;                  (naint.machine-translation.Output.translation
;; ;; ;;                   (naint.machine-translation.translate
;; ;; ;;                    (((naint.machine-translation.MkInput "English") "Chinese")
;; ;; ;;                     (snet.speech-recognition.Text.text
;; ;; ;;                      (snet.speech-recognition.s2t
;; ;; ;;                       (snet.speech-recognition.MkAudio $english-vocals))))))
;; ;; ;;                  (LET $midi-notes (tomidi.MIDI.data (tomidi.MkAudio $english-vocals))
;; ;; ;;                       (LET $chinese-vocals
;; ;; ;;                            (naint.midi2voice-zh.Answer.output_audio
;; ;; ;;                             (naint.midi2voice-zh.singingZH
;; ;; ;;                              (((naint.midi2voice-zh.MkQuery $chinese-lyrics)
;; ;; ;;                                $midi-notes) 1.0)))
;; ;; ;;                            (mixer.Audio.data
;; ;; ;;                             (mixer.mix
;; ;; ;;                              ((mixer.MkMultiAudio
;; ;; ;;                                (snet.sound-spleeter.Output.accomp $spleeter-output))
;; ;; ;;                               $chinese-vocals)))))))))
